# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Москвин А. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    28/12     |      3        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В Прологе, как и во многих других языках программирования, можно хранить не только отдельные элементы, но и какие-то наборы различных элементов. Для этого используется такая структура данных, как список. Списки в Прологе отличаются от списков, например, в языке Python, к которым все так привыкли. Здесь список - это либо пустой элемент, либо один элемент, называемый головой, и присоединенный список - хвост. Это рекурсивная структура данных с последовательным доступом. Прологовский список это скорее некий гибрид очереди и линейного списка. В рамках данной лабораторной работы мне предложено более подробно разобраться с этой структурой данных в Прологе и научиться работать с ней.

## Задание 1.1: Предикат обработки списка

### Стандартные предикаты работы со списками:
```prolog
% Предикат получения длины списка.
my_length([], 0). 
my_lenght([_|Tail], N) :- my_lenght(Tail, N1), 
                        N is N1 + 1.

% Предикат проверки принадлежности элемента X списку List.
my_member(Head, [Head|_]).
my_member(X, [_|Tail]) :- my_member(X, Tail).

% Объединение списков List1 и List2. Результат List3.
my_append([], List2, List2).
my_append([Head | Tail1], List2, [Head | Tail3]) :- my_append(Tail1, List2, Tail3).

% Предикат удаления элемента X из списка List.
my_remove(X,[X|T],T).
my_remove(X,[H|T],[H|Y]) :- my_remove(X,T,Y).

% Предикат проверки перестановки списка
my_permute([],[]).
my_permute(X,[H|T1]) :-
  my_remove(H,X,T),
  my_permute(T,T1).

% Предикат проверки подсписка
my_sublist(Sub, List) :-
	my_append(_, L2, List),
	my_append(Sub, _, L2).
```

`count_entry(X,[H|T],N)` - подсчет числа вхождений N заданного элемента X в список List (без стандартных предикатов)
`std_count_entry` - подсчет числа вхождений N заданного элемента X в список List

Реализация:
```prolog
count_entry(_,[],0).
count_entry(X,[X | Tail], N) :-
	count_entry(X, Tail , N1),
	N is N1 + 1, !.
count_entry(X, [_ | Tail], N) :-
	count_entry(X, Tail, N).
```

Условия рекурсии:

1. При любом элементе, если список пуст, то число вхождений равно 0.
2. Если элемент совпадает с головой списка, то запускаем рекурсивно count_entry только уже с хвостом списка, полученный результат рекурсии будет содержаться в N1, а изначальное число вхождений будет находиться как сумма N1 + 1, т.к. голова списка уже совпала с элементом.
3. Иначе если элемент не совпал с головой списка, то запускаем рекурсию с хвостом списка, не увеличивая число вхождений.

Реализация:
```prolog
std_count_entry(_, [], 0).
std_count_entry(X, List, N) :-
	my_remove(A, List, NEW),
	A = X,
	std_count_entry(X, NEW, N1),
	N is N1 + 1, !.
std_count_entry(X, List, N) :-
	my_remove(A, List, NEW),
	A \= X,
	std_count_entry(X, NEW, N).
```
С помощью стандартного метода перебора и удаления элемента из списка мы рассматриваем каждый элемент и проверяем на совпадение с нужным элементом, если совпало, то запускаем рекурсию и увеличиваем результата на 1, иначе просто запускаем рекурсию.

## Задание 1.2: Предикат обработки числового списка

`max(X,[H|T]) - вычисление максимального элемента (без стандартных предикатов)`
`std_max(X,[H|T]) - вычисление максимального элемента`

Реализация:
```prolog
max(X,[X | Tail]) :-
	maxhelp(X, Tail), !.
max(MAX, [_ | Tail]) :-
	max(MAX, Tail). 
```

Рекурсивно сравниваем потенциальный максимальный элемент с головой списка. Если данный элемент не подошел, то запускаем рекурсию для следующего элемента.

Реализация:
```prolog
std_max(X, [X | Tail]) :- 
	maxhelp(X, Tail), !.
std_max(MAX, [X | Tail]) :-
	my_remove(X, [X | Tail], List),
	std_max(MAX, List).
```

Принцип такой же, как и в реализации вычисления максимального элемента без использования стандартных предикатов, только элемент, который не подошел, удаляется с помощью `remove`.

## Задание 2: Реляционное представление данных

Реляционное представление данных порой оказывается очень удобным для использования. Достоинствами реляционного представления является простота организации базы данных, наличие строгих правил проектирования и полная независимость данных. Однако в качестве недостатков можно выделить относительно большой объём занимаемой памяти.

В моем варианте использовалось представление данных в виде фактов следующей структуры:

```
grade(группа, фамилия, предмет, оценка).
```
### Исходный код программы:
```prolog
% USE UTF-8

:- set_prolog_flag(encoding, utf8).
:-['two.pl'].

% 2.1 Напечатать средний балл для каждого предмета.

% Список предметов
subjects(List) :- setof(Subject, A^B^C^grade(A, B, Subject, C), List).

% Сумма(list, sum_of_elements).
sum([], 0).
sum([Head|Tail], Sum) :- sum(Tail, Sum1), Sum is Sum1 + Head.

% Среднее значение(list, average_value_of_elements).
average(List, Average) :- sum(List, Sum), length(List, Length), Average is Sum / Length.

% Получить средний балл N для предмета S.(subject, average_grade). - 
get_average_grade(Subject, Number) :- findall(Mark, grade(_, _, Subject, Mark), List), 
                                      average(List, Number).

% Напечатать средний балл для каждого предмета
print_average_grades(Subject, Average) :- subjects(Subjects), member(Subject, Subjects), 
                                          get_average_grade(Subject, Average).



% 2.2 Для каждой группы, найти количество не сдавших студентов

% Напечатать количество не сдавших студентов для каждой группы
print_failed_exam(Group, Number) :- setof(Student, A^grade(Group, Student, A, 2), List), 
                                    length(List, Number).



% 2.3 Найти количество не сдавших студентов для каждого из предметов

% Поиск количества студентов (N), не сдавших предмет S.
failed_subject(Subject, Number) :- findall(Student, grade(_, Student, Subject, 2), List), 
                                   length(List, Number).

% Напечатать список всех предметов и количество несдавших его студентов
print_failed_subject(Subject, Number) :- subjects(Subjects), member(Subject, Subjects), 
                                                  failed_subject(Subject, Number).
```
### Список реализованных предикатов:
* `subjects(List)` - Список предметов
* `sum([Head|Tail],Sum)` - Сумма(list, sum_of_elements).
* `average(List, Average)` - Среднее значение(list, average_value_of_elements).
* `get_average_grade(Subject,Number)` - Получить средний балл N для предмета S.(subject, average_grade).
* `print_average_grades(Subject,Average)` - Напечатать средний балл для каждого предмета
* `print_failed_exam(Group,Number)` - Напечатать количество не сдавших студентов для каждой группы
* `failed_subject(Subject,Number)` - Поиск количества студентов (N), не сдавших предмет S.
* `print_failed_subject(Subject,Number)` - Напечатать список всех предметов и количество несдавших его студентов

### Результат работы предикатов:
```
?- subjects(X).
X = ['Английский язык', 'Информатика', 'Логическое программирование', 'Математический анализ', 'Психология', 'Функциональное программирование'].
?- sum([1,2,3], X).
X = 6.
?- average([5,3,2], X).
X = 3.3333333333333335.
?- get_average_grade('Психология', X).            
X = 3.9285714285714284.
?- print_average_grages(Subj,Mark).
Correct to: "print_average_grades(Subj,Mark)"? yes
Subj = 'Английский язык',
Mark = 3.75 ;
Subj = 'Информатика',
Mark = 3.9285714285714284 ;
Subj = 'Логическое программирование',
Mark = 3.9642857142857144 ;
Subj = 'Математический анализ',
Mark = 3.892857142857143 ;
Subj = 'Психология',
Mark = 3.9285714285714284 ;
Subj = 'Функциональное программирование',
Mark = 3.9642857142857144.
?- print_failed_exam(X, Y).
X = 101,
Y = 2 ;
X = 102,
Y = 5 ;
X = 103,
Y = 3 ;
X = 104,
Y = 2.
?- failed_subject('Математический анализ', X).
X = 3.
?- print_failed_subject(X, Y).
X = 'Английский язык',
Y = 4 ;
X = 'Информатика',
Y = 2 ;
X = 'Логическое программирование',
Y = 2 ;
X = 'Математический анализ',
Y = 3 ;
X = 'Психология',
Y = 1 ;
X = 'Функциональное программирование',
Y = 1.
```
## Выводы

Списки в языке Пролог - это действительно необычная структура данных. Для обработки таких списков нужно использовать особые предикаты, которые чаще всего строятся рекурсивно. В рамках данной лабораторной работы были реализованы основные предикаты для обработки числовых и произвольных списков. На первый взгляд может показаться, что Прологовские списки очень неудобны для работы. Однако на самом деле это очень мощная встроенная структура данных, которая позволяет выполнять абсолютно все необходимые функции (стоит только реализовать их предикатами). Наверное, сложно представить себе более простую структуру данных на декларативных языках программирования.
